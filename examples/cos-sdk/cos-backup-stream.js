// Copyright Â© 2025 IBM Corp. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Small script which backs up a Cloudant database to an IBM Cloud Object Storage (COS)
// bucket via a stream rather than on-disk file, authenticating with IBM IAM
//
// The script generates the backup object name by combining together the path
// part of the database URL and the current time.

const stream = require('stream');
const IBM_COS = require('ibm-cos-sdk');
const VError = require('verror').VError;
const couchbackup = require('@cloudant/couchbackup');
const debug = require('debug')('couchbackup-cos');
const url = require('url');

/*
  Main function, run from base of file.
*/
function main() {
  const argv = require('yargs')
    .usage('Usage: $0 [options]')
    .example('$0 -s https://~replaceWithYourUniqueHost~.cloudantnosqldb.appdomain.cloud/db -b <bucket> --cos_url <url>', 'Backup db to bucket using IAM authentication')
    .options({
      source: { alias: 's', nargs: 1, demandOption: true, describe: 'Source database URL' },
      bucket: { alias: 'b', nargs: 1, demandOption: true, describe: 'Destination bucket' },
      prefix: { alias: 'p', nargs: 1, describe: 'Prefix for backup object key', default: 'couchbackup' },
      cos_url: { nargs: 1, demandOption: true, describe: 'IBM COS S3 endpoint URL' }, // An endpoint from 'endpoints' list in cos_credentials
      shallow: { describe: 'Backup the documents winning revisions only', type: 'boolean' }
    })
    .help('h').alias('h', 'help')
    .epilog('Copyright (C) IBM 2025')
    .argv;

  const sourceUrl = argv.source;
  const backupBucket = argv.bucket;
  const backupName = new url.URL(sourceUrl).pathname.split('/').filter(function(x) { return x; }).join('-');
  const backupKeyPrefix = `${argv.prefix}-${backupName}`;
  const backupKey = `${backupKeyPrefix}-${new Date().toISOString()}`;
  const cosEndpoint = argv.cos_url;
  const cloudantApiKey = process.env.CLOUDANT_IAM_API_KEY;
  const mode = argv.shallow ? 'shallow' : 'full';

  /*
  * Creds are from ~/.bluemix/cos_credentials, generated by ibmcloud CLI tool
  * See: https://cloud.ibm.com/docs/cloud-object-storage?topic=cloud-object-storage-service-credentials
  *
  * corresponding 'endpoint' can be found on IBM Cloud UI at the COS instance,
  * or under the 'endpoints' link provided in the generated file (~/.bluemix/cos_credentials)
  *  */
  const config = {
    endpoint: cosEndpoint,
    credentials: new IBM_COS.SharedJSONFileCredentials(),
  };
  const COS = new IBM_COS.S3(config);
  debug(`Creating a new backup of ${sourceUrl} at ${backupBucket}/${backupKey}...`);
  bucketAccessible(COS, backupBucket)
    .then(() => {
      return backupToS3(sourceUrl, COS, backupBucket, backupKey, cloudantApiKey, mode);
    })
    .then(() => {
      debug('Backup successful!');
    })
    .catch((reason) => {
      debug(`Error: ${reason}`);
      process.exit(1);
    });
}

/**
 * Return a promise that resolves if the bucket is available and
 * rejects if not.
 *
 * @param {IBM_COS.S3} s3 IBM COS S3 client object
 * @param {any} bucketName Bucket name
 * @returns Promise
 */
function bucketAccessible(s3, bucketName) {
  const params = {
    Bucket: bucketName
  };
  return s3.headBucket(params).promise()
    .then(() => { debug('Bucket is accessible'); })
    .catch((reason) => {
      console.error(reason);
      throw new VError(reason, 'Bucket is not accessible');
    });
}

/**
 * Backup directly from Cloudant to an object store object via a stream.
 *
 * @param {any} sourceUrl URL of database
 * @param {any} s3Client Object store client
 * @param {any} s3Bucket Backup destination bucket
 * @param {any} s3Key Backup destination key name (shouldn't exist)
 * @param {any} mode couchbackup `shallow` or `full` mode
 * @returns Promise
 */
function backupToS3(sourceUrl, s3Client, s3Bucket, s3Key, cloudantApiKey, mode) {
  debug(`Setting up IBM COS upload to ${s3Bucket}/${s3Key}`);

  // A pass through stream that has couchbackup's output
  // written to it and it then read by the S3 upload client.
  // It has a 64MB highwater mark to allow for fairly
  // uneven network connectivity.
  const streamToUpload = new stream.PassThrough({ highWaterMark: 64 * 1024 * 1024 });

  // Set up IBM COS upload.
  const params = {
    Bucket: s3Bucket,
    Key: s3Key,
    Body: streamToUpload
  };
  const options = {
    partSize: 5 * 1024 * 1024, // max 5 MB part size (minimum size)
    queueSize: 5  // allow 5 parts at a time
  };
  const upload = s3Client.upload(params, options);
  upload.on('httpUploadProgress', (progress) => {
    debug(`IBM COS upload progress: ${JSON.stringify(progress)}`);
  });
  debug(`Starting streaming data from ${sourceUrl}`);
  debug(`Using couchbackup mode: ${mode}`);
  const couchbackupParams = {
    iamApiKey: cloudantApiKey,
    mode,
    ...(process.env.CLOUDANT_IAM_TOKEN_URL && { iamTokenUrl: process.env.CLOUDANT_IAM_TOKEN_URL }),
  };
  const backupPromise = new Promise((resolve, reject) => couchbackup.backup(
    sourceUrl,
    streamToUpload,
    couchbackupParams,
    (err, done) => {
      if (err) {
        debug(err);
        reject(new VError(err, 'CouchBackup process failed'));
      } else {
        streamToUpload.end(); // must call end() to complete upload.
        resolve(done);
      }
    }
  )
    .on('changes', batch => debug('Couchbackup changes batch: ', batch))
    .on('written', progress => debug('Fetched batch:', progress.batch, 'Total document revisions written:', progress.total, 'Time:', progress.time))
  );
  return Promise.all([backupPromise, upload.promise()]);
}

main();
